#!/usr/bin/env python3
"""
SkillComposerSkill - Dynamically create, validate, and register new skills at runtime.

This is a core self-improvement capability: the agent can identify needs,
generate new skill code, validate it, and register it for immediate use.
No human intervention required.

Actions:
  - create: Generate a new skill from a specification
  - validate: Check generated skill code for correctness
  - register: Load and register a dynamic skill into the registry
  - list_dynamic: List all dynamically created skills
  - export: Export a dynamic skill source code
  - describe_template: Show the skill template for reference
"""

import ast
import importlib
import importlib.util
import os
import sys
import textwrap
import time
from pathlib import Path
from typing import Dict, List, Optional

from .base import Skill, SkillManifest, SkillAction, SkillResult


# Template for generating new skills
SKILL_TEMPLATE = '''\
"""
{description}

Auto-generated by SkillComposerSkill at {timestamp}
"""

from typing import Dict
from singularity.skills.base import Skill, SkillManifest, SkillAction, SkillResult


class {class_name}(Skill):
    """{description}"""

    def __init__(self, credentials: Dict = None):
        super().__init__(credentials)

    @property
    def manifest(self) -> SkillManifest:
        return SkillManifest(
            skill_id="{skill_id}",
            name="{name}",
            version="1.0.0",
            category="{category}",
            description="{description}",
            actions=[
{actions_code}
            ],
            required_credentials=[{credentials_list}],
            author="skill_composer",
        )

    async def execute(self, action: str, params: Dict) -> SkillResult:
{execute_body}
'''


def _generate_action_code(action: dict) -> str:
    """Generate SkillAction(...) code from an action specification."""
    name = action.get("name", "unnamed")
    desc = action.get("description", "")
    params = action.get("parameters", {})

    params_dict_parts = []
    for pname, pinfo in params.items():
        if isinstance(pinfo, dict):
            ptype = pinfo.get("type", "str")
            required = pinfo.get("required", False)
            pdesc = pinfo.get("description", "")
            params_dict_parts.append(
                f'"{pname}": {{"type": "{ptype}", "required": {required}, "description": "{pdesc}"}}'
            )
        else:
            params_dict_parts.append(f'"{pname}": {{"type": "str", "required": True, "description": ""}}')

    params_code = "{" + ", ".join(params_dict_parts) + "}"

    return (
        f'                SkillAction(\n'
        f'                    name="{name}",\n'
        f'                    description="{desc}",\n'
        f'                    parameters={params_code},\n'
        f'                ),\n'
    )


def _generate_execute_body(actions: list) -> str:
    """Generate the execute method body with action dispatch."""
    if not actions:
        return '        return SkillResult(success=False, message="No actions defined")\n'

    lines = []
    for i, action in enumerate(actions):
        name = action.get("name", "unnamed")
        desc = action.get("description", "No description")
        logic = action.get("logic", None)

        prefix = "if" if i == 0 else "elif"
        lines.append(f'        {prefix} action == "{name}":')

        if logic:
            # User-provided logic (each line indented)
            for logic_line in logic.strip().split("\n"):
                lines.append(f"            {logic_line}")
        else:
            # Default implementation - return success with params echoed
            lines.append(f'            return SkillResult(')
            lines.append(f'                success=True,')
            lines.append(f'                message="{desc}",')
            lines.append(f'                data={{"action": "{name}", "params": params}},')
            lines.append(f'            )')

    lines.append(f'        else:')
    lines.append(f'            return SkillResult(success=False, message=f"Unknown action: {{action}}")')
    lines.append('')

    return "\n".join(lines) + "\n"


def _to_class_name(name: str) -> str:
    """Convert a name like 'my_cool_skill' to 'MyCoolSkill'."""
    # Remove 'Skill' suffix if present, we'll add it back
    name = name.replace("Skill", "").replace("skill", "")
    parts = name.replace("-", "_").split("_")
    class_name = "".join(p.capitalize() for p in parts if p) + "Skill"
    return class_name


def _to_skill_id(name: str) -> str:
    """Convert a name to a skill_id like 'my_cool'."""
    name = name.replace("Skill", "").replace("skill", "")
    name = name.replace("-", "_")
    # Handle CamelCase
    result = []
    for i, c in enumerate(name):
        if c.isupper() and i > 0 and name[i - 1].islower():
            result.append("_")
        result.append(c.lower())
    return "".join(result).strip("_")


def validate_skill_code(source_code: str) -> dict:
    """
    Validate generated skill code.

    Returns dict with:
      - valid: bool
      - errors: list of error messages
      - warnings: list of warnings
      - class_name: detected class name (if found)
    """
    errors = []
    warnings = []
    class_name = None

    # 1. Syntax check
    try:
        tree = ast.parse(source_code)
    except SyntaxError as e:
        return {
            "valid": False,
            "errors": [f"Syntax error at line {e.lineno}: {e.msg}"],
            "warnings": [],
            "class_name": None,
        }

    # 2. Find Skill subclass
    skill_classes = []
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            for base in node.bases:
                base_name = ""
                if isinstance(base, ast.Name):
                    base_name = base.id
                elif isinstance(base, ast.Attribute):
                    base_name = base.attr
                if base_name == "Skill":
                    skill_classes.append(node.name)

    if not skill_classes:
        errors.append("No class extending 'Skill' found")
    elif len(skill_classes) > 1:
        warnings.append(f"Multiple Skill subclasses found: {skill_classes}")

    if skill_classes:
        class_name = skill_classes[0]

    # 3. Check for required methods
    if skill_classes:
        for cls_node in ast.walk(tree):
            if isinstance(cls_node, ast.ClassDef) and cls_node.name == class_name:
                method_names = [
                    n.name for n in cls_node.body if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))
                ]
                # Check for manifest property
                has_manifest = "manifest" in method_names
                has_execute = "execute" in method_names

                if not has_manifest:
                    errors.append(f"Class {class_name} missing 'manifest' property")
                if not has_execute:
                    errors.append(f"Class {class_name} missing 'execute' method")

    # 4. Check imports
    has_skill_import = False
    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom):
            if node.module and "base" in node.module:
                for alias in node.names:
                    if alias.name == "Skill":
                        has_skill_import = True
    if not has_skill_import:
        warnings.append("No import of 'Skill' from base module detected")

    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings,
        "class_name": class_name,
    }


class SkillComposerSkill(Skill):
    """Dynamically create, validate, and register new skills at runtime."""

    def __init__(self, credentials: Dict = None, dynamic_skills_dir: str = None):
        super().__init__(credentials)
        self._dynamic_dir = Path(dynamic_skills_dir) if dynamic_skills_dir else None
        self._created_skills: Dict[str, dict] = {}  # skill_id -> metadata
        self._registry = None  # Set by agent to enable runtime registration

    def set_registry(self, registry):
        """Set the SkillRegistry for runtime registration of new skills."""
        self._registry = registry

    def _get_dynamic_dir(self) -> Path:
        """Get or create the dynamic skills directory."""
        if self._dynamic_dir:
            d = self._dynamic_dir
        else:
            d = Path.home() / ".singularity" / "dynamic_skills"
        d.mkdir(parents=True, exist_ok=True)
        return d

    @property
    def manifest(self) -> SkillManifest:
        return SkillManifest(
            skill_id="skill_composer",
            name="Skill Composer",
            version="1.0.0",
            category="self_improvement",
            description="Dynamically create, validate, and register new skills at runtime. "
                        "Core self-improvement capability for autonomous skill expansion.",
            actions=[
                SkillAction(
                    name="create",
                    description="Generate a new skill from a specification. Provide name, description, "
                                "category, and a list of actions with their parameters.",
                    parameters={
                        "name": {"type": "str", "required": True, "description": "Skill name (e.g. 'data_analyzer')"},
                        "description": {"type": "str", "required": True, "description": "What the skill does"},
                        "category": {"type": "str", "required": False, "description": "Skill category (default: 'dynamic')"},
                        "actions": {"type": "list", "required": True,
                                    "description": "List of action dicts with name, description, parameters, and optional logic"},
                        "required_credentials": {"type": "list", "required": False, "description": "List of required credential keys"},
                    },
                ),
                SkillAction(
                    name="create_from_code",
                    description="Create a skill from raw Python source code. The code must define "
                                "a class extending Skill with manifest and execute.",
                    parameters={
                        "name": {"type": "str", "required": True, "description": "Skill name for identification"},
                        "source_code": {"type": "str", "required": True, "description": "Complete Python source code"},
                    },
                ),
                SkillAction(
                    name="validate",
                    description="Validate a skill's source code for correctness (syntax, structure, imports).",
                    parameters={
                        "skill_id": {"type": "str", "required": False, "description": "ID of a previously created skill to validate"},
                        "source_code": {"type": "str", "required": False, "description": "Raw source code to validate"},
                    },
                ),
                SkillAction(
                    name="register",
                    description="Load a dynamically created skill and register it in the agent's skill registry.",
                    parameters={
                        "skill_id": {"type": "str", "required": True, "description": "ID of the skill to register"},
                    },
                ),
                SkillAction(
                    name="list_dynamic",
                    description="List all dynamically created skills with their metadata.",
                    parameters={},
                ),
                SkillAction(
                    name="export",
                    description="Export the source code of a dynamically created skill.",
                    parameters={
                        "skill_id": {"type": "str", "required": True, "description": "ID of the skill to export"},
                    },
                ),
                SkillAction(
                    name="describe_template",
                    description="Show the skill template structure for reference when creating skills.",
                    parameters={},
                ),
            ],
            required_credentials=[],
            author="singularity",
        )

    async def execute(self, action: str, params: Dict) -> SkillResult:
        if action == "create":
            return await self._create(params)
        elif action == "create_from_code":
            return await self._create_from_code(params)
        elif action == "validate":
            return await self._validate(params)
        elif action == "register":
            return await self._register(params)
        elif action == "list_dynamic":
            return await self._list_dynamic(params)
        elif action == "export":
            return await self._export(params)
        elif action == "describe_template":
            return await self._describe_template(params)
        else:
            return SkillResult(success=False, message=f"Unknown action: {action}")

    async def _create(self, params: Dict) -> SkillResult:
        """Generate a new skill from a specification."""
        name = params.get("name")
        description = params.get("description", "A dynamically created skill")
        category = params.get("category", "dynamic")
        actions = params.get("actions", [])
        required_creds = params.get("required_credentials", [])

        if not name:
            return SkillResult(success=False, message="'name' is required")
        if not actions:
            return SkillResult(success=False, message="'actions' list is required with at least one action")

        class_name = _to_class_name(name)
        skill_id = _to_skill_id(name)

        # Generate action code
        actions_code = ""
        for action in actions:
            actions_code += _generate_action_code(action)

        # Generate execute body
        execute_body = _generate_execute_body(actions)

        # Generate credentials list
        creds_list = ", ".join(f'"{c}"' for c in required_creds)

        # Fill template
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        source_code = SKILL_TEMPLATE.format(
            class_name=class_name,
            skill_id=skill_id,
            name=name.replace("_", " ").title(),
            description=description,
            category=category,
            actions_code=actions_code,
            execute_body=execute_body,
            credentials_list=creds_list,
            timestamp=timestamp,
        )

        # Validate
        validation = validate_skill_code(source_code)
        if not validation["valid"]:
            return SkillResult(
                success=False,
                message=f"Generated code failed validation: {validation['errors']}",
                data={"source_code": source_code, "validation": validation},
            )

        # Save to disk
        dynamic_dir = self._get_dynamic_dir()
        filepath = dynamic_dir / f"{skill_id}.py"
        filepath.write_text(source_code)

        # Track metadata
        self._created_skills[skill_id] = {
            "skill_id": skill_id,
            "class_name": class_name,
            "name": name,
            "description": description,
            "category": category,
            "filepath": str(filepath),
            "created_at": timestamp,
            "registered": False,
            "action_count": len(actions),
        }

        return SkillResult(
            success=True,
            message=f"Skill '{name}' created successfully as {class_name} with {len(actions)} actions",
            data={
                "skill_id": skill_id,
                "class_name": class_name,
                "filepath": str(filepath),
                "validation": validation,
                "action_count": len(actions),
            },
        )

    async def _create_from_code(self, params: Dict) -> SkillResult:
        """Create a skill from raw Python source code."""
        name = params.get("name")
        source_code = params.get("source_code")

        if not name:
            return SkillResult(success=False, message="'name' is required")
        if not source_code:
            return SkillResult(success=False, message="'source_code' is required")

        # Validate
        validation = validate_skill_code(source_code)
        if not validation["valid"]:
            return SkillResult(
                success=False,
                message=f"Code validation failed: {validation['errors']}",
                data={"validation": validation},
            )

        skill_id = _to_skill_id(name)
        class_name = validation["class_name"] or _to_class_name(name)

        # Save to disk
        dynamic_dir = self._get_dynamic_dir()
        filepath = dynamic_dir / f"{skill_id}.py"
        filepath.write_text(source_code)

        timestamp = time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        self._created_skills[skill_id] = {
            "skill_id": skill_id,
            "class_name": class_name,
            "name": name,
            "description": f"Custom skill from code: {name}",
            "category": "dynamic",
            "filepath": str(filepath),
            "created_at": timestamp,
            "registered": False,
        }

        return SkillResult(
            success=True,
            message=f"Skill '{name}' saved from code as {class_name}",
            data={
                "skill_id": skill_id,
                "class_name": class_name,
                "filepath": str(filepath),
                "validation": validation,
            },
        )

    async def _validate(self, params: Dict) -> SkillResult:
        """Validate skill source code."""
        source_code = params.get("source_code")
        skill_id = params.get("skill_id")

        if not source_code and skill_id:
            # Load from created skills
            meta = self._created_skills.get(skill_id)
            if not meta:
                return SkillResult(success=False, message=f"Skill '{skill_id}' not found in created skills")
            filepath = Path(meta["filepath"])
            if not filepath.exists():
                return SkillResult(success=False, message=f"Skill file not found: {filepath}")
            source_code = filepath.read_text()

        if not source_code:
            return SkillResult(success=False, message="Provide 'source_code' or 'skill_id' to validate")

        validation = validate_skill_code(source_code)
        return SkillResult(
            success=validation["valid"],
            message="Validation passed" if validation["valid"] else f"Validation failed: {validation['errors']}",
            data={"validation": validation},
        )

    async def _register(self, params: Dict) -> SkillResult:
        """Load and register a dynamic skill into the agent's registry."""
        skill_id = params.get("skill_id")
        if not skill_id:
            return SkillResult(success=False, message="'skill_id' is required")

        meta = self._created_skills.get(skill_id)
        if not meta:
            # Try loading from disk
            dynamic_dir = self._get_dynamic_dir()
            filepath = dynamic_dir / f"{skill_id}.py"
            if not filepath.exists():
                return SkillResult(success=False, message=f"Skill '{skill_id}' not found")
            meta = {
                "skill_id": skill_id,
                "filepath": str(filepath),
                "class_name": None,
            }

        filepath = Path(meta["filepath"])
        if not filepath.exists():
            return SkillResult(success=False, message=f"Skill file not found: {filepath}")

        # Load the module dynamically
        source_code = filepath.read_text()

        # Validate first
        validation = validate_skill_code(source_code)
        if not validation["valid"]:
            return SkillResult(
                success=False,
                message=f"Skill code failed validation: {validation['errors']}",
                data={"validation": validation},
            )

        class_name = meta.get("class_name") or validation["class_name"]
        if not class_name:
            return SkillResult(success=False, message="Could not determine skill class name")

        try:
            # Dynamic import
            module_name = f"dynamic_skill_{skill_id}"
            spec = importlib.util.spec_from_file_location(module_name, str(filepath))
            module = importlib.util.module_from_spec(spec)
            sys.modules[module_name] = module
            spec.loader.exec_module(module)

            # Get the skill class
            skill_class = getattr(module, class_name, None)
            if skill_class is None:
                return SkillResult(
                    success=False,
                    message=f"Class '{class_name}' not found in module",
                )

            # Register in the registry if available
            if self._registry:
                self._registry.install(skill_class)
                meta["registered"] = True
                return SkillResult(
                    success=True,
                    message=f"Skill '{skill_id}' ({class_name}) loaded and registered successfully",
                    data={"skill_id": skill_id, "class_name": class_name, "registered": True},
                )
            else:
                # No registry, just verify it can be instantiated
                instance = skill_class()
                meta["registered"] = False
                return SkillResult(
                    success=True,
                    message=f"Skill '{skill_id}' ({class_name}) loaded and validated but no registry available",
                    data={"skill_id": skill_id, "class_name": class_name, "registered": False},
                )

        except Exception as e:
            return SkillResult(
                success=False,
                message=f"Failed to load skill: {type(e).__name__}: {e}",
            )

    async def _list_dynamic(self, params: Dict) -> SkillResult:
        """List all dynamically created skills."""
        # Also scan the dynamic directory for skills not in memory
        dynamic_dir = self._get_dynamic_dir()
        disk_skills = {}
        for f in dynamic_dir.glob("*.py"):
            sid = f.stem
            if sid not in self._created_skills:
                disk_skills[sid] = {
                    "skill_id": sid,
                    "filepath": str(f),
                    "source": "disk",
                    "registered": False,
                }

        all_skills = {**disk_skills, **self._created_skills}

        return SkillResult(
            success=True,
            message=f"Found {len(all_skills)} dynamic skill(s)",
            data={
                "skills": list(all_skills.values()),
                "dynamic_dir": str(dynamic_dir),
                "count": len(all_skills),
            },
        )

    async def _export(self, params: Dict) -> SkillResult:
        """Export the source code of a dynamic skill."""
        skill_id = params.get("skill_id")
        if not skill_id:
            return SkillResult(success=False, message="'skill_id' is required")

        # Check in-memory first
        meta = self._created_skills.get(skill_id)
        if meta:
            filepath = Path(meta["filepath"])
        else:
            filepath = self._get_dynamic_dir() / f"{skill_id}.py"

        if not filepath.exists():
            return SkillResult(success=False, message=f"Skill file not found: {filepath}")

        source_code = filepath.read_text()
        return SkillResult(
            success=True,
            message=f"Source code for skill '{skill_id}' ({len(source_code)} chars)",
            data={"skill_id": skill_id, "source_code": source_code, "filepath": str(filepath)},
        )

    async def _describe_template(self, params: Dict) -> SkillResult:
        """Show the skill template for reference."""
        example_spec = {
            "name": "data_processor",
            "description": "Process and transform data in various formats",
            "category": "data",
            "actions": [
                {
                    "name": "transform",
                    "description": "Transform data from one format to another",
                    "parameters": {
                        "input_data": {"type": "str", "required": True, "description": "Input data"},
                        "format": {"type": "str", "required": True, "description": "Target format (json, csv, xml)"},
                    },
                },
                {
                    "name": "summarize",
                    "description": "Generate a summary of the data",
                    "parameters": {
                        "input_data": {"type": "str", "required": True, "description": "Data to summarize"},
                    },
                },
            ],
        }

        return SkillResult(
            success=True,
            message="Skill template and example specification",
            data={
                "template_structure": (
                    "A skill needs:\n"
                    "1. A class extending Skill\n"
                    "2. A 'manifest' property returning SkillManifest\n"
                    "3. An async 'execute(action, params)' method\n"
                    "4. Actions listed in the manifest with parameters"
                ),
                "example_spec": example_spec,
                "usage": (
                    "Use skill_composer:create with a spec like the example above. "
                    "Then skill_composer:register to load it into the agent. "
                    "Or use skill_composer:create_from_code to provide raw Python."
                ),
            },
        )
